<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?css2?family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Poppins:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600&family=Roboto:ital,wght@0,100..600;1,100..600&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
    integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="../css/note.css">
  <link rel="shortcut icon" href="img/favicon.png" type="image/x-icon">
</head>

<body>
  <main class="abundance">
    <div class="header">
      <div class="h1"><label>School:</label><span>Abundance Model College</span></div>
      <div class="h1"><label>Class:</label><span>Senior Secondary School 3</span></div>
      <div class="h1"><label>Subject:</label><span>Computer Studies</span></div>
      <div class="h1"><label>Topic:</label><span>Indexing In Database Systems</span></div>
    </div>

    <div class="content">
      <p><b>Introduction</b></p>
      </p>
        In database systems, efficient data retrieval is one of the most critical aspects of performance. When databases grow
        large, searching for data without any form of optimization can become slow and resource-intensive. Indexes are special
        data structures that improve the speed of data retrieval operations on a database table, similar to how an index in a
        textbook helps you quickly locate a topic without reading the entire book.      
      </p>
      <br>

      <p><b>Definition of an Index</b></p>
      </p>
        An index is a database object that provides a fast and efficient way to access data in a table based on specific columns.
        It works like a “lookup table” that helps the database management system (DBMS) quickly locate records without scanning
        the entire table.
      </p>
      <p><b>In simple term:</b></p>
      <p>i. An index is a data structure that stores the values of one or more columns and pointers to the corresponding rows in a table.</p>
      <p>ii. It is used primarily to speed up SELECT queries and WHERE clause filtering.</p>
      <p>iii. While indexes improve read operations, they can slightly slow down INSERT, UPDATE, and DELETE operations because the
        index also needs to be updated.
      </p>
      <br>

      <p><b>Clustered Versus Non-clustered Indexes</b></p>
      <p><b>1. Clustered Index:</b></p>
      <p> A clustered index determines the physical order of data in a table. In other words, the data rows are stored in the same
        order as the index.
      </p>
      <p>i. A table can have only one clustered index because the data rows themselves can only be sorted in one order.</p>
      <p>ii. The primary key of a table is often created as a clustered index by default.</p>
      <br>

      <p><b>2. Unclustered (Non-Clustered) Index:</b></p>
      <p> An unclustered index, also called a non-clustered index, does not affect the physical order of data in the table.
        Instead, it creates a separate structure (a copy of selected columns and pointers) that points to the location of the
        data rows in the table.
      </p>
      <p>i. A table can have multiple non-clustered indexes.</p>
      <p>ii. It’s like having a separate “lookup list” that points to where the data is actually stored.</p>
      
      <br>

      <div class="table-ctn">
        <p><b>Comparison: </b>Clustered Versus Unclustered Indexes</p>
        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>Clustered Index</th>
              <th>Unclustered Index</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Physical Order of Data:</b></td>
              <td>Data rows are stored in the same order as the index.</td>
              <td>Data rows are stored separately from the index structure.</td>
            </tr>
            <tr>
              <td><b>Number per Table:</b></td>
              <td>Only one clustered index is allowed per table.</td>
              <td>Multiple unclustered indexes can be created.</td>
            </tr>
            <tr>
              <td><b>Storage Requirement:</b></td>
              <td>Does not require extra storage because data itself acts as the index.</td>
              <td>Requires additional storage space for the index structure.</td>
            </tr>
            <tr>
              <td><b>Data Retrieval Speed:</b></td>
              <td>Faster for range queries and large result sets.</td>
              <td>Faster for point lookups and smaller result sets.</td>
            </tr>
            <tr>
              <td><b>Example Use Case:</b></td>
              <td>Primary key columns, where data is frequently retrieved in sorted order.</td>
              <td>Columns used frequently in WHERE clauses or JOIN conditions.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <br>
      <p><b>Note: </b>Beyond the basic classification of indexes as <b>Clustered</b> or <b>Non-clustered</b>, indexes can also be classified based on record coverage, relation to data file order, and key composition.</p>
      <br>

      <p><b>Dense Versus Sparse Indexes:</b></p>
      <p><b>1. Dense Index:</b></p>
      <p> A dense index contains an index record (or entry) for every search key value in the data file.
        That means every data record in the table has a corresponding index entry.
      </p>
      <p>i. Each entry in the dense index holds the search key value and a pointer (address) to the record in the data file.</p>
      <p>ii. Dense indexes are typically used when direct access to every record is desired or when the data file is unordered.</p>
      <br>

      <p><b>2. Sparse Index:</b></p>
      <p> A sparse index contains entries for only some of the records in the data file.
        Typically, one index entry is created for each data block or page, pointing to the first record in that block.
      </p>
      <p>i. The data file must be sorted (ordered) on the search key for sparse indexing to be effective.</p>
      <p>ii. Once the appropriate block is located through the index, the specific record is searched sequentially within that block.</p>
      <br>

      <div class="table-ctn">
        <p><b>Comparison: </b>Dense Versus Sparse Index</p>
        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>Dense Index</th>
              <th>Sparse Index</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Index Entries:</b></td>
              <td>One entry per record.</td>
              <td>One entry per block or group of records.</td>
            </tr>
            <tr>
              <td><b>Storage Space:</b></td>
              <td>High.</td>
              <td>Low.</td>
            </tr>
            <tr>
              <td><b>Search Time:</b></td>
              <td>Faster (direct access).</td>
              <td>Slower (requires block search).</td>
            </tr>
            <tr>
              <td><b>File Organization:</b></td>
              <td>Works with ordered and unordered files.</td>
              <td>Requires ordered data files.</td>
            </tr>
            <tr>
              <td><b>Example Use Case:</b></td>
              <td>Typically used for secondary indexing.</td>
              <td>Commonly used for primary indexing.</td>
            </tr>
          </tbody>
        </table>
      </div>
      <br>
      
      <p><b>Primary and Secondary Indexes: </b> The classification of indexes as primary or secondary depends on their relationship to the ordering of data records in
      the data file.</p>
      <p><b>1. Primary Index:</b></p>
      <p> A primary index is built on a field that defines the physical ordering of records in the data file — usually the primary key.
        In other words, the data file is stored in sorted order on the key field used by the primary index.
      </p>
      <p>i. Each index entry contains the key value and a pointer to the first record with that key value.</p>
      <p>ii. Since the data file is ordered, a sparse index is typically used</p>
      <br>

      <p><b>2. Secondary Index:</b></p>
      <p> A secondary index is created on a non-ordering field — that is, a field that does not define the physical storage order of the data file.
        It provides an alternative access path to data records.
      </p>
      <p>i. Usually dense because the data file is not ordered by that key.</p>
      <p>ii. Used when queries frequently involve non-primary key columns.</p>
      <br>

      <div class="table-ctn">
        <p><b>Comparison: </b>Primary Versus Secondary Index</p>
        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>Primary Index</th>
              <th>Secondary Index</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Based On:</b></td>
              <td>Ordering key (usually primary key)</td>
              <td>Non-ordering field</td>
            </tr>
            <tr>
              <td><b>Index Type:</b></td>
              <td>Usually sparse.</td>
              <td>Usually dense.</td>
            </tr>
            <tr>
              <td><b>Data File Organization:</b></td>
              <td>Data file is ordered on the key.</td>
              <td>Data file is unordered.</td>
            </tr>
            <tr>
              <td><b>Number Allowed:</b></td>
              <td>Only one per table.</td>
              <td>Multiple per table.</td>
            </tr>
            <tr>
              <td><b>Storage Requirement:</b></td>
              <td>Low</td>
              <td>High.</td>
            </tr>
          </tbody>
        </table>
      </div>
      <br>

      <p><b>Indexes Using Composite Search Keys:</b></p>
      <p> A composite search key index (also known as a multi-level or concatenated key index) is built on two or more columns of a table.
        The combined values of these columns form the search key used in the index.
      </p>
      <p>i. Composite indexes improve performance for queries involving multiple columns in combination.</p>
      <p>ii. The order of columns in the composite key is crucial — the index is most efficient when queries filter based on the
      leading column(s).</p>
      <br>

      <div class="table-ctn">
        <p><b>Comparison: </b>Single-Column Versus Composite Indexes</p>
        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>Single-Column</th>
              <th>Composite</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Indexed Columns:</b></td>
              <td>One</td>
              <td>Two or More</td>
            </tr>
            <tr>
              <td><b>Query Optimization:</b></td>
              <td>Best for filters on single field.</td>
              <td>Best for queries involving multiple fields.</td>
            </tr>
            <tr>
              <td><b>Storage Requirement:</b></td>
              <td>Less.</td>
              <td>More.</td>
            </tr>
            <tr>
              <td><b>Flexibility:</b></td>
              <td>Limited.</td>
              <td>High, if queries match key order.</td>
            </tr>
            <tr>
              <td><b>Example Use Case:</b></td>
              <td>Search by Student_ID.</td>
              <td>Search by Department and Year.</td>
            </tr>
          </tbody>
        </table>
      </div>
      <br>

      <p><b>Remark: </b>This is the complete note for the week One and Two, explanations will come in our next class, endeavor to complete your note before then.</p>
    </div>
  </main>

  <script src="js/navigate.js"></script>
</body>

</html>
